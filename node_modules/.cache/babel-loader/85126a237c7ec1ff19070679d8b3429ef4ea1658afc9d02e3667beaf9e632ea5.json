{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport * as React from \"react\";\nimport { useMeasure } from \"./use-measure\";\nimport { GridContext } from \"./GridContext\";\nimport { swap } from \"./swap\";\nimport { getPositionForIndex, getTargetIndex } from \"./helpers\";\nimport { GridItemContext } from \"./GridItemContext\";\nexport function GridDropZone(_a) {\n  var id = _a.id,\n    boxesPerRow = _a.boxesPerRow,\n    children = _a.children,\n    style = _a.style,\n    _b = _a.disableDrag,\n    disableDrag = _b === void 0 ? false : _b,\n    _c = _a.disableDrop,\n    disableDrop = _c === void 0 ? false : _c,\n    rowHeight = _a.rowHeight,\n    other = tslib_1.__rest(_a, [\"id\", \"boxesPerRow\", \"children\", \"style\", \"disableDrag\", \"disableDrop\", \"rowHeight\"]);\n  var _d = React.useContext(GridContext),\n    traverse = _d.traverse,\n    startTraverse = _d.startTraverse,\n    endTraverse = _d.endTraverse,\n    register = _d.register,\n    measureAll = _d.measureAll,\n    onChange = _d.onChange,\n    remove = _d.remove,\n    getActiveDropId = _d.getActiveDropId;\n  var ref = React.useRef(null);\n  var _e = useMeasure(ref),\n    bounds = _e.bounds,\n    remeasure = _e.remeasure;\n  var _f = tslib_1.__read(React.useState(null), 2),\n    draggingIndex = _f[0],\n    setDraggingIndex = _f[1];\n  var _g = tslib_1.__read(React.useState(null), 2),\n    placeholder = _g[0],\n    setPlaceholder = _g[1];\n  var traverseIndex = traverse && !traverse.execute && traverse.targetId === id ? traverse.targetIndex : null;\n  var grid = {\n    columnWidth: bounds.width / boxesPerRow,\n    boxesPerRow: boxesPerRow,\n    rowHeight: rowHeight\n  };\n  var childCount = React.Children.count(children);\n  /**\n   * Register our dropzone with our grid context\n   */\n  React.useEffect(function () {\n    register(id, {\n      top: bounds.top,\n      bottom: bounds.bottom,\n      left: bounds.left,\n      right: bounds.right,\n      width: bounds.width,\n      height: bounds.height,\n      count: childCount,\n      grid: grid,\n      disableDrop: disableDrop,\n      remeasure: remeasure\n    });\n  }, [childCount, disableDrop, bounds, id, grid]);\n  /**\n   * Unregister when unmounting\n   */\n  React.useEffect(function () {\n    return function () {\n      return remove(id);\n    };\n  }, [id]);\n  // keep an initial list of our item indexes. We use this\n  // when animating swap positions on drag events\n  var itemsIndexes = React.Children.map(children, function (_, i) {\n    return i;\n  });\n  return React.createElement(\"div\", tslib_1.__assign({\n    ref: ref,\n    style: tslib_1.__assign({\n      position: \"relative\"\n    }, style)\n  }, other), grid.columnWidth === 0 ? null : React.Children.map(children, function (child, i) {\n    var isTraverseTarget = traverse && traverse.targetId === id && traverse.targetIndex === i;\n    var order = placeholder ? swap(itemsIndexes, placeholder.startIndex, placeholder.targetIndex) : itemsIndexes;\n    var pos = getPositionForIndex(order.indexOf(i), grid, traverseIndex);\n    /**\n     * Handle a child being dragged\n     * @param state\n     * @param x\n     * @param y\n     */\n    function onMove(state, x, y) {\n      if (!ref.current) return;\n      if (draggingIndex !== i) {\n        setDraggingIndex(i);\n      }\n      var targetDropId = getActiveDropId(id, x + grid.columnWidth / 2, y + grid.rowHeight / 2);\n      if (targetDropId && targetDropId !== id) {\n        startTraverse(id, targetDropId, x, y, i);\n      } else {\n        endTraverse();\n      }\n      var targetIndex = targetDropId !== id ? childCount : getTargetIndex(i, grid, childCount, state.delta[0], state.delta[1]);\n      if (targetIndex !== i) {\n        if (placeholder && placeholder.targetIndex !== targetIndex || !placeholder) {\n          setPlaceholder({\n            targetIndex: targetIndex,\n            startIndex: i\n          });\n        }\n      } else if (placeholder) {\n        setPlaceholder(null);\n      }\n    }\n    /**\n     * Handle drag end events\n     */\n    function onEnd(state, x, y) {\n      var targetDropId = getActiveDropId(id, x + grid.columnWidth / 2, y + grid.rowHeight / 2);\n      var targetIndex = targetDropId !== id ? childCount : getTargetIndex(i, grid, childCount, state.delta[0], state.delta[1]);\n      // traverse?\n      if (traverse) {\n        onChange(traverse.sourceId, traverse.sourceIndex, traverse.targetIndex, traverse.targetId);\n      } else {\n        onChange(id, i, targetIndex);\n      }\n      setPlaceholder(null);\n      setDraggingIndex(null);\n    }\n    function onStart() {\n      measureAll();\n    }\n    return React.createElement(GridItemContext.Provider, {\n      value: {\n        top: pos.xy[1],\n        disableDrag: disableDrag,\n        endTraverse: endTraverse,\n        mountWithTraverseTarget: isTraverseTarget ? [traverse.tx, traverse.ty] : undefined,\n        left: pos.xy[0],\n        i: i,\n        onMove: onMove,\n        onEnd: onEnd,\n        onStart: onStart,\n        grid: grid,\n        dragging: i === draggingIndex\n      }\n    }, child);\n  }));\n}","map":{"version":3,"names":["tslib_1","React","useMeasure","GridContext","swap","getPositionForIndex","getTargetIndex","GridItemContext","GridDropZone","_a","id","boxesPerRow","children","style","_b","disableDrag","_c","disableDrop","rowHeight","other","__rest","_d","useContext","traverse","startTraverse","endTraverse","register","measureAll","onChange","remove","getActiveDropId","ref","useRef","_e","bounds","remeasure","_f","__read","useState","draggingIndex","setDraggingIndex","_g","placeholder","setPlaceholder","traverseIndex","execute","targetId","targetIndex","grid","columnWidth","width","childCount","Children","count","useEffect","top","bottom","left","right","height","itemsIndexes","map","_","i","createElement","__assign","position","child","isTraverseTarget","order","startIndex","pos","indexOf","onMove","state","x","y","current","targetDropId","delta","onEnd","sourceId","sourceIndex","onStart","Provider","value","xy","mountWithTraverseTarget","tx","ty","undefined","dragging"],"sources":["C:/Users/LearnForce/Desktop/Task/puzzle-app/node_modules/react-grid-dnd/esm/GridDropZone.js"],"sourcesContent":["import * as tslib_1 from \"tslib\";\nimport * as React from \"react\";\nimport { useMeasure } from \"./use-measure\";\nimport { GridContext } from \"./GridContext\";\nimport { swap } from \"./swap\";\nimport { getPositionForIndex, getTargetIndex } from \"./helpers\";\nimport { GridItemContext } from \"./GridItemContext\";\nexport function GridDropZone(_a) {\n    var id = _a.id, boxesPerRow = _a.boxesPerRow, children = _a.children, style = _a.style, _b = _a.disableDrag, disableDrag = _b === void 0 ? false : _b, _c = _a.disableDrop, disableDrop = _c === void 0 ? false : _c, rowHeight = _a.rowHeight, other = tslib_1.__rest(_a, [\"id\", \"boxesPerRow\", \"children\", \"style\", \"disableDrag\", \"disableDrop\", \"rowHeight\"]);\n    var _d = React.useContext(GridContext), traverse = _d.traverse, startTraverse = _d.startTraverse, endTraverse = _d.endTraverse, register = _d.register, measureAll = _d.measureAll, onChange = _d.onChange, remove = _d.remove, getActiveDropId = _d.getActiveDropId;\n    var ref = React.useRef(null);\n    var _e = useMeasure(ref), bounds = _e.bounds, remeasure = _e.remeasure;\n    var _f = tslib_1.__read(React.useState(null), 2), draggingIndex = _f[0], setDraggingIndex = _f[1];\n    var _g = tslib_1.__read(React.useState(null), 2), placeholder = _g[0], setPlaceholder = _g[1];\n    var traverseIndex = traverse && !traverse.execute && traverse.targetId === id\n        ? traverse.targetIndex\n        : null;\n    var grid = {\n        columnWidth: bounds.width / boxesPerRow,\n        boxesPerRow: boxesPerRow,\n        rowHeight: rowHeight\n    };\n    var childCount = React.Children.count(children);\n    /**\n     * Register our dropzone with our grid context\n     */\n    React.useEffect(function () {\n        register(id, {\n            top: bounds.top,\n            bottom: bounds.bottom,\n            left: bounds.left,\n            right: bounds.right,\n            width: bounds.width,\n            height: bounds.height,\n            count: childCount,\n            grid: grid,\n            disableDrop: disableDrop,\n            remeasure: remeasure\n        });\n    }, [childCount, disableDrop, bounds, id, grid]);\n    /**\n     * Unregister when unmounting\n     */\n    React.useEffect(function () {\n        return function () { return remove(id); };\n    }, [id]);\n    // keep an initial list of our item indexes. We use this\n    // when animating swap positions on drag events\n    var itemsIndexes = React.Children.map(children, function (_, i) { return i; });\n    return (React.createElement(\"div\", tslib_1.__assign({ ref: ref, style: tslib_1.__assign({ position: \"relative\" }, style) }, other), grid.columnWidth === 0\n        ? null\n        : React.Children.map(children, function (child, i) {\n            var isTraverseTarget = traverse &&\n                traverse.targetId === id &&\n                traverse.targetIndex === i;\n            var order = placeholder\n                ? swap(itemsIndexes, placeholder.startIndex, placeholder.targetIndex)\n                : itemsIndexes;\n            var pos = getPositionForIndex(order.indexOf(i), grid, traverseIndex);\n            /**\n             * Handle a child being dragged\n             * @param state\n             * @param x\n             * @param y\n             */\n            function onMove(state, x, y) {\n                if (!ref.current)\n                    return;\n                if (draggingIndex !== i) {\n                    setDraggingIndex(i);\n                }\n                var targetDropId = getActiveDropId(id, x + grid.columnWidth / 2, y + grid.rowHeight / 2);\n                if (targetDropId && targetDropId !== id) {\n                    startTraverse(id, targetDropId, x, y, i);\n                }\n                else {\n                    endTraverse();\n                }\n                var targetIndex = targetDropId !== id\n                    ? childCount\n                    : getTargetIndex(i, grid, childCount, state.delta[0], state.delta[1]);\n                if (targetIndex !== i) {\n                    if ((placeholder && placeholder.targetIndex !== targetIndex) ||\n                        !placeholder) {\n                        setPlaceholder({\n                            targetIndex: targetIndex,\n                            startIndex: i\n                        });\n                    }\n                }\n                else if (placeholder) {\n                    setPlaceholder(null);\n                }\n            }\n            /**\n             * Handle drag end events\n             */\n            function onEnd(state, x, y) {\n                var targetDropId = getActiveDropId(id, x + grid.columnWidth / 2, y + grid.rowHeight / 2);\n                var targetIndex = targetDropId !== id\n                    ? childCount\n                    : getTargetIndex(i, grid, childCount, state.delta[0], state.delta[1]);\n                // traverse?\n                if (traverse) {\n                    onChange(traverse.sourceId, traverse.sourceIndex, traverse.targetIndex, traverse.targetId);\n                }\n                else {\n                    onChange(id, i, targetIndex);\n                }\n                setPlaceholder(null);\n                setDraggingIndex(null);\n            }\n            function onStart() {\n                measureAll();\n            }\n            return (React.createElement(GridItemContext.Provider, { value: {\n                    top: pos.xy[1],\n                    disableDrag: disableDrag,\n                    endTraverse: endTraverse,\n                    mountWithTraverseTarget: isTraverseTarget\n                        ? [traverse.tx, traverse.ty]\n                        : undefined,\n                    left: pos.xy[0],\n                    i: i,\n                    onMove: onMove,\n                    onEnd: onEnd,\n                    onStart: onStart,\n                    grid: grid,\n                    dragging: i === draggingIndex\n                } }, child));\n        })));\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}