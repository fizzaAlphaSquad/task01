{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport * as React from \"react\";\nimport { isMouseEnabled } from \"./mouse-enabled\";\nvar initialState = {\n  time: Date.now(),\n  xy: [0, 0],\n  delta: [0, 0],\n  initial: [0, 0],\n  previous: [0, 0],\n  direction: [0, 0],\n  initialDirection: [0, 0],\n  local: [0, 0],\n  lastLocal: [0, 0],\n  velocity: 0,\n  distance: 0\n};\nvar defaultConfig = {\n  enableMouse: true\n};\nvar grantedTouch = null;\nexport function useGestureResponder(options, config) {\n  if (options === void 0) {\n    options = {};\n  }\n  if (config === void 0) {\n    config = {};\n  }\n  var state = React.useRef(initialState);\n  var _a = tslib_1.__assign({}, defaultConfig, config),\n    uid = _a.uid,\n    enableMouse = _a.enableMouse;\n  var id = React.useRef(uid || Math.random());\n  var pressed = React.useRef(false);\n  // update our callbacks when they change\n  var callbackRefs = React.useRef(options);\n  React.useEffect(function () {\n    callbackRefs.current = options;\n  }, [options]);\n  /**\n   * Attempt to claim the active touch\n   */\n  function claimTouch(e) {\n    if (grantedTouch && grantedTouch.onTerminationRequest(e)) {\n      grantedTouch.onTerminate(e);\n      grantedTouch = null;\n    }\n    attemptGrant(e);\n  }\n  /**\n   * Attempt to claim the active touch\n   * @param e\n   */\n  function attemptGrant(e) {\n    // if a touch is already active we won't register\n    if (grantedTouch) {\n      return;\n    }\n    grantedTouch = {\n      id: id.current,\n      onTerminate: onTerminate,\n      onTerminationRequest: onTerminationRequest\n    };\n    onGrant(e);\n  }\n  function bindGlobalMouseEvents() {\n    window.addEventListener(\"mousemove\", handleMoveMouse, false);\n    window.addEventListener(\"mousemove\", handleMoveMouseCapture, true);\n    window.addEventListener(\"mouseup\", handleEndMouse);\n  }\n  function unbindGlobalMouseEvents() {\n    window.removeEventListener(\"mousemove\", handleMoveMouse, false);\n    window.removeEventListener(\"mousemove\", handleMoveMouseCapture, true);\n    window.removeEventListener(\"mouseup\", handleEndMouse);\n  }\n  function handleStartCapture(e) {\n    updateStartState(e);\n    pressed.current = true;\n    var granted = onStartShouldSetCapture(e);\n    if (granted) {\n      attemptGrant(e);\n    }\n  }\n  function handleStart(e) {\n    updateStartState(e);\n    pressed.current = true;\n    bindGlobalMouseEvents();\n    var granted = onStartShouldSet(e);\n    if (granted) {\n      attemptGrant(e);\n    }\n  }\n  function isGrantedTouch() {\n    return grantedTouch && grantedTouch.id === id.current;\n  }\n  /**\n   * Handle touchend / mouseup events\n   * @param e\n   */\n  function handleEnd(e) {\n    pressed.current = false;\n    unbindGlobalMouseEvents();\n    if (!isGrantedTouch()) {\n      return;\n    }\n    // remove touch\n    grantedTouch = null;\n    onRelease(e);\n  }\n  /**\n   * Handle touchmove / mousemove capture events\n   * @param e\n   */\n  function handleMoveCapture(e) {\n    updateMoveState(e);\n    if (isGrantedTouch()) {\n      return;\n    }\n    if (onMoveShouldSetCapture(e)) {\n      claimTouch(e);\n    }\n  }\n  /**\n   * Handle touchmove / mousemove events\n   * @param e\n   */\n  function handleMove(e) {\n    if (isGrantedTouch()) {\n      onMove(e);\n      return;\n    }\n    if (onMoveShouldSet(e)) {\n      claimTouch(e);\n    }\n  }\n  /**\n   * When our gesture starts, should we become the responder?\n   */\n  function onStartShouldSet(e) {\n    return callbackRefs.current.onStartShouldSet ? callbackRefs.current.onStartShouldSet(state.current, e) : false;\n  }\n  /**\n   * Same as onStartShouldSet, except using capture.\n   */\n  function onStartShouldSetCapture(e) {\n    return callbackRefs.current.onStartShouldSetCapture ? callbackRefs.current.onStartShouldSetCapture(state.current, e) : false;\n  }\n  /**\n   * When our gesture moves, should we become the responder?\n   */\n  function onMoveShouldSet(e) {\n    return callbackRefs.current.onMoveShouldSet ? callbackRefs.current.onMoveShouldSet(state.current, e) : false;\n  }\n  /**\n   * Same as onMoveShouldSet, but using capture instead\n   * of bubbling.\n   */\n  function onMoveShouldSetCapture(e) {\n    return callbackRefs.current.onMoveShouldSetCapture ? callbackRefs.current.onMoveShouldSetCapture(state.current, e) : false;\n  }\n  /**\n   * The view is responding to gestures. Typically corresponds\n   * with mousedown or touchstart.\n   * @param e\n   */\n  function onGrant(e) {\n    if (callbackRefs.current.onGrant) {\n      callbackRefs.current.onGrant(state.current, e);\n    }\n  }\n  /**\n   * Update our kinematics for start events\n   * @param e\n   */\n  function updateStartState(e) {\n    var _a = e.touches && e.touches[0] ? e.touches[0] : e,\n      pageX = _a.pageX,\n      pageY = _a.pageY;\n    var s = state.current;\n    state.current = tslib_1.__assign({}, initialState, {\n      lastLocal: s.lastLocal || initialState.lastLocal,\n      xy: [pageX, pageY],\n      initial: [pageX, pageY],\n      previous: [pageX, pageY],\n      time: Date.now()\n    });\n  }\n  /**\n   * Update our kinematics when moving\n   * @param e\n   */\n  function updateMoveState(e) {\n    var _a = e.touches && e.touches[0] ? e.touches[0] : e,\n      pageX = _a.pageX,\n      pageY = _a.pageY;\n    var s = state.current;\n    var time = Date.now();\n    var x_dist = pageX - s.xy[0];\n    var y_dist = pageY - s.xy[1];\n    var delta_x = pageX - s.initial[0];\n    var delta_y = pageY - s.initial[1];\n    var distance = Math.sqrt(delta_x * delta_x + delta_y * delta_y);\n    var len = Math.sqrt(x_dist * x_dist + y_dist * y_dist);\n    var scaler = 1 / (len || 1);\n    var velocity = len / (time - s.time);\n    var initialDirection = s.initialDirection[0] !== 0 || s.initialDirection[1] !== 0 ? s.initialDirection : [delta_x * scaler, delta_y * scaler];\n    state.current = tslib_1.__assign({}, state.current, {\n      time: time,\n      xy: [pageX, pageY],\n      initialDirection: initialDirection,\n      delta: [delta_x, delta_y],\n      local: [s.lastLocal[0] + pageX - s.initial[0], s.lastLocal[1] + pageY - s.initial[1]],\n      velocity: time - s.time === 0 ? s.velocity : velocity,\n      distance: distance,\n      direction: [x_dist * scaler, y_dist * scaler],\n      previous: s.xy\n    });\n  }\n  /**\n   * The user is moving their touch / mouse.\n   * @param e\n   */\n  function onMove(e) {\n    if (pressed.current && callbackRefs.current.onMove) {\n      callbackRefs.current.onMove(state.current, e);\n    }\n  }\n  /**\n   * The responder has been released. Typically mouse-up or\n   * touchend events.\n   * @param e\n   */\n  function onRelease(e) {\n    var s = state.current;\n    state.current = tslib_1.__assign({}, state.current, {\n      lastLocal: s.local\n    });\n    if (callbackRefs.current.onRelease) {\n      callbackRefs.current.onRelease(state.current, e);\n    }\n    grantedTouch = null;\n  }\n  /**\n   * Check with the current responder to see if it can\n   * be terminated. This is currently only triggered when returns true\n   * from onMoveShouldSet. I can't really envision much of a\n   * use-case for doing this with a standard onStartShouldSet.\n   *\n   * By default, returns true.\n   */\n  function onTerminationRequest(e) {\n    return callbackRefs.current.onTerminationRequest ? callbackRefs.current.onTerminationRequest(state.current, e) : true;\n  }\n  /**\n   * The responder has been taken by another view\n   */\n  function onTerminate(e) {\n    var s = state.current;\n    state.current = tslib_1.__assign({}, state.current, {\n      lastLocal: s.local\n    });\n    if (callbackRefs.current.onTerminate) {\n      callbackRefs.current.onTerminate(state.current, e);\n    }\n  }\n  /**\n   * Use window mousemove events instead of binding to the\n   * element itself to better emulate how touchmove works.\n   */\n  function handleMoveMouse(e) {\n    if (isMouseEnabled()) {\n      handleMove(e);\n    }\n  }\n  function handleMoveMouseCapture(e) {\n    if (isMouseEnabled()) {\n      handleMoveCapture(e);\n    }\n  }\n  function handleEndMouse(e) {\n    if (isMouseEnabled()) {\n      handleEnd(e);\n    }\n  }\n  React.useEffect(function () {\n    return unbindGlobalMouseEvents;\n  }, []);\n  /**\n   * Imperatively terminate the current responder\n   */\n  function terminateCurrentResponder() {\n    if (grantedTouch) {\n      grantedTouch.onTerminate();\n      grantedTouch = null;\n    }\n  }\n  /**\n   * A getter for returning the current\n   * responder, if it exists\n   */\n  function getCurrentResponder() {\n    return grantedTouch;\n  }\n  /**\n   * Required touch / mouse events\n   */\n  var touchEvents = {\n    onTouchStart: handleStart,\n    onTouchEnd: handleEnd,\n    onTouchMove: handleMove,\n    onTouchStartCapture: handleStartCapture,\n    onTouchMoveCapture: handleMoveCapture\n  };\n  var mouseEvents = enableMouse ? {\n    onMouseDown: function (e) {\n      if (isMouseEnabled()) {\n        handleStart(e);\n      }\n    },\n    onMouseDownCapture: function (e) {\n      if (isMouseEnabled()) {\n        handleStartCapture(e);\n      }\n    }\n  } : {};\n  return {\n    bind: tslib_1.__assign({}, touchEvents, mouseEvents),\n    terminateCurrentResponder: terminateCurrentResponder,\n    getCurrentResponder: getCurrentResponder\n  };\n}","map":{"version":3,"names":["tslib_1","React","isMouseEnabled","initialState","time","Date","now","xy","delta","initial","previous","direction","initialDirection","local","lastLocal","velocity","distance","defaultConfig","enableMouse","grantedTouch","useGestureResponder","options","config","state","useRef","_a","__assign","uid","id","Math","random","pressed","callbackRefs","useEffect","current","claimTouch","e","onTerminationRequest","onTerminate","attemptGrant","onGrant","bindGlobalMouseEvents","window","addEventListener","handleMoveMouse","handleMoveMouseCapture","handleEndMouse","unbindGlobalMouseEvents","removeEventListener","handleStartCapture","updateStartState","granted","onStartShouldSetCapture","handleStart","onStartShouldSet","isGrantedTouch","handleEnd","onRelease","handleMoveCapture","updateMoveState","onMoveShouldSetCapture","handleMove","onMove","onMoveShouldSet","touches","pageX","pageY","s","x_dist","y_dist","delta_x","delta_y","sqrt","len","scaler","terminateCurrentResponder","getCurrentResponder","touchEvents","onTouchStart","onTouchEnd","onTouchMove","onTouchStartCapture","onTouchMoveCapture","mouseEvents","onMouseDown","onMouseDownCapture","bind"],"sources":["C:/Users/LearnForce/Desktop/Task/puzzle-app/node_modules/react-gesture-responder/esm/index.js"],"sourcesContent":["import * as tslib_1 from \"tslib\";\nimport * as React from \"react\";\nimport { isMouseEnabled } from \"./mouse-enabled\";\nvar initialState = {\n    time: Date.now(),\n    xy: [0, 0],\n    delta: [0, 0],\n    initial: [0, 0],\n    previous: [0, 0],\n    direction: [0, 0],\n    initialDirection: [0, 0],\n    local: [0, 0],\n    lastLocal: [0, 0],\n    velocity: 0,\n    distance: 0\n};\nvar defaultConfig = {\n    enableMouse: true\n};\nvar grantedTouch = null;\nexport function useGestureResponder(options, config) {\n    if (options === void 0) { options = {}; }\n    if (config === void 0) { config = {}; }\n    var state = React.useRef(initialState);\n    var _a = tslib_1.__assign({}, defaultConfig, config), uid = _a.uid, enableMouse = _a.enableMouse;\n    var id = React.useRef(uid || Math.random());\n    var pressed = React.useRef(false);\n    // update our callbacks when they change\n    var callbackRefs = React.useRef(options);\n    React.useEffect(function () {\n        callbackRefs.current = options;\n    }, [options]);\n    /**\n     * Attempt to claim the active touch\n     */\n    function claimTouch(e) {\n        if (grantedTouch && grantedTouch.onTerminationRequest(e)) {\n            grantedTouch.onTerminate(e);\n            grantedTouch = null;\n        }\n        attemptGrant(e);\n    }\n    /**\n     * Attempt to claim the active touch\n     * @param e\n     */\n    function attemptGrant(e) {\n        // if a touch is already active we won't register\n        if (grantedTouch) {\n            return;\n        }\n        grantedTouch = {\n            id: id.current,\n            onTerminate: onTerminate,\n            onTerminationRequest: onTerminationRequest\n        };\n        onGrant(e);\n    }\n    function bindGlobalMouseEvents() {\n        window.addEventListener(\"mousemove\", handleMoveMouse, false);\n        window.addEventListener(\"mousemove\", handleMoveMouseCapture, true);\n        window.addEventListener(\"mouseup\", handleEndMouse);\n    }\n    function unbindGlobalMouseEvents() {\n        window.removeEventListener(\"mousemove\", handleMoveMouse, false);\n        window.removeEventListener(\"mousemove\", handleMoveMouseCapture, true);\n        window.removeEventListener(\"mouseup\", handleEndMouse);\n    }\n    function handleStartCapture(e) {\n        updateStartState(e);\n        pressed.current = true;\n        var granted = onStartShouldSetCapture(e);\n        if (granted) {\n            attemptGrant(e);\n        }\n    }\n    function handleStart(e) {\n        updateStartState(e);\n        pressed.current = true;\n        bindGlobalMouseEvents();\n        var granted = onStartShouldSet(e);\n        if (granted) {\n            attemptGrant(e);\n        }\n    }\n    function isGrantedTouch() {\n        return grantedTouch && grantedTouch.id === id.current;\n    }\n    /**\n     * Handle touchend / mouseup events\n     * @param e\n     */\n    function handleEnd(e) {\n        pressed.current = false;\n        unbindGlobalMouseEvents();\n        if (!isGrantedTouch()) {\n            return;\n        }\n        // remove touch\n        grantedTouch = null;\n        onRelease(e);\n    }\n    /**\n     * Handle touchmove / mousemove capture events\n     * @param e\n     */\n    function handleMoveCapture(e) {\n        updateMoveState(e);\n        if (isGrantedTouch()) {\n            return;\n        }\n        if (onMoveShouldSetCapture(e)) {\n            claimTouch(e);\n        }\n    }\n    /**\n     * Handle touchmove / mousemove events\n     * @param e\n     */\n    function handleMove(e) {\n        if (isGrantedTouch()) {\n            onMove(e);\n            return;\n        }\n        if (onMoveShouldSet(e)) {\n            claimTouch(e);\n        }\n    }\n    /**\n     * When our gesture starts, should we become the responder?\n     */\n    function onStartShouldSet(e) {\n        return callbackRefs.current.onStartShouldSet\n            ? callbackRefs.current.onStartShouldSet(state.current, e)\n            : false;\n    }\n    /**\n     * Same as onStartShouldSet, except using capture.\n     */\n    function onStartShouldSetCapture(e) {\n        return callbackRefs.current.onStartShouldSetCapture\n            ? callbackRefs.current.onStartShouldSetCapture(state.current, e)\n            : false;\n    }\n    /**\n     * When our gesture moves, should we become the responder?\n     */\n    function onMoveShouldSet(e) {\n        return callbackRefs.current.onMoveShouldSet\n            ? callbackRefs.current.onMoveShouldSet(state.current, e)\n            : false;\n    }\n    /**\n     * Same as onMoveShouldSet, but using capture instead\n     * of bubbling.\n     */\n    function onMoveShouldSetCapture(e) {\n        return callbackRefs.current.onMoveShouldSetCapture\n            ? callbackRefs.current.onMoveShouldSetCapture(state.current, e)\n            : false;\n    }\n    /**\n     * The view is responding to gestures. Typically corresponds\n     * with mousedown or touchstart.\n     * @param e\n     */\n    function onGrant(e) {\n        if (callbackRefs.current.onGrant) {\n            callbackRefs.current.onGrant(state.current, e);\n        }\n    }\n    /**\n     * Update our kinematics for start events\n     * @param e\n     */\n    function updateStartState(e) {\n        var _a = e.touches && e.touches[0] ? e.touches[0] : e, pageX = _a.pageX, pageY = _a.pageY;\n        var s = state.current;\n        state.current = tslib_1.__assign({}, initialState, { lastLocal: s.lastLocal || initialState.lastLocal, xy: [pageX, pageY], initial: [pageX, pageY], previous: [pageX, pageY], time: Date.now() });\n    }\n    /**\n     * Update our kinematics when moving\n     * @param e\n     */\n    function updateMoveState(e) {\n        var _a = e.touches && e.touches[0] ? e.touches[0] : e, pageX = _a.pageX, pageY = _a.pageY;\n        var s = state.current;\n        var time = Date.now();\n        var x_dist = pageX - s.xy[0];\n        var y_dist = pageY - s.xy[1];\n        var delta_x = pageX - s.initial[0];\n        var delta_y = pageY - s.initial[1];\n        var distance = Math.sqrt(delta_x * delta_x + delta_y * delta_y);\n        var len = Math.sqrt(x_dist * x_dist + y_dist * y_dist);\n        var scaler = 1 / (len || 1);\n        var velocity = len / (time - s.time);\n        var initialDirection = s.initialDirection[0] !== 0 || s.initialDirection[1] !== 0\n            ? s.initialDirection\n            : [delta_x * scaler, delta_y * scaler];\n        state.current = tslib_1.__assign({}, state.current, { time: time, xy: [pageX, pageY], initialDirection: initialDirection, delta: [delta_x, delta_y], local: [\n                s.lastLocal[0] + pageX - s.initial[0],\n                s.lastLocal[1] + pageY - s.initial[1]\n            ], velocity: time - s.time === 0 ? s.velocity : velocity, distance: distance, direction: [x_dist * scaler, y_dist * scaler], previous: s.xy });\n    }\n    /**\n     * The user is moving their touch / mouse.\n     * @param e\n     */\n    function onMove(e) {\n        if (pressed.current && callbackRefs.current.onMove) {\n            callbackRefs.current.onMove(state.current, e);\n        }\n    }\n    /**\n     * The responder has been released. Typically mouse-up or\n     * touchend events.\n     * @param e\n     */\n    function onRelease(e) {\n        var s = state.current;\n        state.current = tslib_1.__assign({}, state.current, { lastLocal: s.local });\n        if (callbackRefs.current.onRelease) {\n            callbackRefs.current.onRelease(state.current, e);\n        }\n        grantedTouch = null;\n    }\n    /**\n     * Check with the current responder to see if it can\n     * be terminated. This is currently only triggered when returns true\n     * from onMoveShouldSet. I can't really envision much of a\n     * use-case for doing this with a standard onStartShouldSet.\n     *\n     * By default, returns true.\n     */\n    function onTerminationRequest(e) {\n        return callbackRefs.current.onTerminationRequest\n            ? callbackRefs.current.onTerminationRequest(state.current, e)\n            : true;\n    }\n    /**\n     * The responder has been taken by another view\n     */\n    function onTerminate(e) {\n        var s = state.current;\n        state.current = tslib_1.__assign({}, state.current, { lastLocal: s.local });\n        if (callbackRefs.current.onTerminate) {\n            callbackRefs.current.onTerminate(state.current, e);\n        }\n    }\n    /**\n     * Use window mousemove events instead of binding to the\n     * element itself to better emulate how touchmove works.\n     */\n    function handleMoveMouse(e) {\n        if (isMouseEnabled()) {\n            handleMove(e);\n        }\n    }\n    function handleMoveMouseCapture(e) {\n        if (isMouseEnabled()) {\n            handleMoveCapture(e);\n        }\n    }\n    function handleEndMouse(e) {\n        if (isMouseEnabled()) {\n            handleEnd(e);\n        }\n    }\n    React.useEffect(function () { return unbindGlobalMouseEvents; }, []);\n    /**\n     * Imperatively terminate the current responder\n     */\n    function terminateCurrentResponder() {\n        if (grantedTouch) {\n            grantedTouch.onTerminate();\n            grantedTouch = null;\n        }\n    }\n    /**\n     * A getter for returning the current\n     * responder, if it exists\n     */\n    function getCurrentResponder() {\n        return grantedTouch;\n    }\n    /**\n     * Required touch / mouse events\n     */\n    var touchEvents = {\n        onTouchStart: handleStart,\n        onTouchEnd: handleEnd,\n        onTouchMove: handleMove,\n        onTouchStartCapture: handleStartCapture,\n        onTouchMoveCapture: handleMoveCapture\n    };\n    var mouseEvents = enableMouse\n        ? {\n            onMouseDown: function (e) {\n                if (isMouseEnabled()) {\n                    handleStart(e);\n                }\n            },\n            onMouseDownCapture: function (e) {\n                if (isMouseEnabled()) {\n                    handleStartCapture(e);\n                }\n            }\n        }\n        : {};\n    return {\n        bind: tslib_1.__assign({}, touchEvents, mouseEvents),\n        terminateCurrentResponder: terminateCurrentResponder,\n        getCurrentResponder: getCurrentResponder\n    };\n}\n"],"mappings":"AAAA,OAAO,KAAKA,OAAO,MAAM,OAAO;AAChC,OAAO,KAAKC,KAAK,MAAM,OAAO;AAC9B,SAASC,cAAc,QAAQ,iBAAiB;AAChD,IAAIC,YAAY,GAAG;EACfC,IAAI,EAAEC,IAAI,CAACC,GAAG,EAAE;EAChBC,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;EACVC,KAAK,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;EACbC,OAAO,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;EACfC,QAAQ,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;EAChBC,SAAS,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;EACjBC,gBAAgB,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;EACxBC,KAAK,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;EACbC,SAAS,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;EACjBC,QAAQ,EAAE,CAAC;EACXC,QAAQ,EAAE;AACd,CAAC;AACD,IAAIC,aAAa,GAAG;EAChBC,WAAW,EAAE;AACjB,CAAC;AACD,IAAIC,YAAY,GAAG,IAAI;AACvB,OAAO,SAASC,mBAAmBA,CAACC,OAAO,EAAEC,MAAM,EAAE;EACjD,IAAID,OAAO,KAAK,KAAK,CAAC,EAAE;IAAEA,OAAO,GAAG,CAAC,CAAC;EAAE;EACxC,IAAIC,MAAM,KAAK,KAAK,CAAC,EAAE;IAAEA,MAAM,GAAG,CAAC,CAAC;EAAE;EACtC,IAAIC,KAAK,GAAGtB,KAAK,CAACuB,MAAM,CAACrB,YAAY,CAAC;EACtC,IAAIsB,EAAE,GAAGzB,OAAO,CAAC0B,QAAQ,CAAC,CAAC,CAAC,EAAET,aAAa,EAAEK,MAAM,CAAC;IAAEK,GAAG,GAAGF,EAAE,CAACE,GAAG;IAAET,WAAW,GAAGO,EAAE,CAACP,WAAW;EAChG,IAAIU,EAAE,GAAG3B,KAAK,CAACuB,MAAM,CAACG,GAAG,IAAIE,IAAI,CAACC,MAAM,EAAE,CAAC;EAC3C,IAAIC,OAAO,GAAG9B,KAAK,CAACuB,MAAM,CAAC,KAAK,CAAC;EACjC;EACA,IAAIQ,YAAY,GAAG/B,KAAK,CAACuB,MAAM,CAACH,OAAO,CAAC;EACxCpB,KAAK,CAACgC,SAAS,CAAC,YAAY;IACxBD,YAAY,CAACE,OAAO,GAAGb,OAAO;EAClC,CAAC,EAAE,CAACA,OAAO,CAAC,CAAC;EACb;AACJ;AACA;EACI,SAASc,UAAUA,CAACC,CAAC,EAAE;IACnB,IAAIjB,YAAY,IAAIA,YAAY,CAACkB,oBAAoB,CAACD,CAAC,CAAC,EAAE;MACtDjB,YAAY,CAACmB,WAAW,CAACF,CAAC,CAAC;MAC3BjB,YAAY,GAAG,IAAI;IACvB;IACAoB,YAAY,CAACH,CAAC,CAAC;EACnB;EACA;AACJ;AACA;AACA;EACI,SAASG,YAAYA,CAACH,CAAC,EAAE;IACrB;IACA,IAAIjB,YAAY,EAAE;MACd;IACJ;IACAA,YAAY,GAAG;MACXS,EAAE,EAAEA,EAAE,CAACM,OAAO;MACdI,WAAW,EAAEA,WAAW;MACxBD,oBAAoB,EAAEA;IAC1B,CAAC;IACDG,OAAO,CAACJ,CAAC,CAAC;EACd;EACA,SAASK,qBAAqBA,CAAA,EAAG;IAC7BC,MAAM,CAACC,gBAAgB,CAAC,WAAW,EAAEC,eAAe,EAAE,KAAK,CAAC;IAC5DF,MAAM,CAACC,gBAAgB,CAAC,WAAW,EAAEE,sBAAsB,EAAE,IAAI,CAAC;IAClEH,MAAM,CAACC,gBAAgB,CAAC,SAAS,EAAEG,cAAc,CAAC;EACtD;EACA,SAASC,uBAAuBA,CAAA,EAAG;IAC/BL,MAAM,CAACM,mBAAmB,CAAC,WAAW,EAAEJ,eAAe,EAAE,KAAK,CAAC;IAC/DF,MAAM,CAACM,mBAAmB,CAAC,WAAW,EAAEH,sBAAsB,EAAE,IAAI,CAAC;IACrEH,MAAM,CAACM,mBAAmB,CAAC,SAAS,EAAEF,cAAc,CAAC;EACzD;EACA,SAASG,kBAAkBA,CAACb,CAAC,EAAE;IAC3Bc,gBAAgB,CAACd,CAAC,CAAC;IACnBL,OAAO,CAACG,OAAO,GAAG,IAAI;IACtB,IAAIiB,OAAO,GAAGC,uBAAuB,CAAChB,CAAC,CAAC;IACxC,IAAIe,OAAO,EAAE;MACTZ,YAAY,CAACH,CAAC,CAAC;IACnB;EACJ;EACA,SAASiB,WAAWA,CAACjB,CAAC,EAAE;IACpBc,gBAAgB,CAACd,CAAC,CAAC;IACnBL,OAAO,CAACG,OAAO,GAAG,IAAI;IACtBO,qBAAqB,EAAE;IACvB,IAAIU,OAAO,GAAGG,gBAAgB,CAAClB,CAAC,CAAC;IACjC,IAAIe,OAAO,EAAE;MACTZ,YAAY,CAACH,CAAC,CAAC;IACnB;EACJ;EACA,SAASmB,cAAcA,CAAA,EAAG;IACtB,OAAOpC,YAAY,IAAIA,YAAY,CAACS,EAAE,KAAKA,EAAE,CAACM,OAAO;EACzD;EACA;AACJ;AACA;AACA;EACI,SAASsB,SAASA,CAACpB,CAAC,EAAE;IAClBL,OAAO,CAACG,OAAO,GAAG,KAAK;IACvBa,uBAAuB,EAAE;IACzB,IAAI,CAACQ,cAAc,EAAE,EAAE;MACnB;IACJ;IACA;IACApC,YAAY,GAAG,IAAI;IACnBsC,SAAS,CAACrB,CAAC,CAAC;EAChB;EACA;AACJ;AACA;AACA;EACI,SAASsB,iBAAiBA,CAACtB,CAAC,EAAE;IAC1BuB,eAAe,CAACvB,CAAC,CAAC;IAClB,IAAImB,cAAc,EAAE,EAAE;MAClB;IACJ;IACA,IAAIK,sBAAsB,CAACxB,CAAC,CAAC,EAAE;MAC3BD,UAAU,CAACC,CAAC,CAAC;IACjB;EACJ;EACA;AACJ;AACA;AACA;EACI,SAASyB,UAAUA,CAACzB,CAAC,EAAE;IACnB,IAAImB,cAAc,EAAE,EAAE;MAClBO,MAAM,CAAC1B,CAAC,CAAC;MACT;IACJ;IACA,IAAI2B,eAAe,CAAC3B,CAAC,CAAC,EAAE;MACpBD,UAAU,CAACC,CAAC,CAAC;IACjB;EACJ;EACA;AACJ;AACA;EACI,SAASkB,gBAAgBA,CAAClB,CAAC,EAAE;IACzB,OAAOJ,YAAY,CAACE,OAAO,CAACoB,gBAAgB,GACtCtB,YAAY,CAACE,OAAO,CAACoB,gBAAgB,CAAC/B,KAAK,CAACW,OAAO,EAAEE,CAAC,CAAC,GACvD,KAAK;EACf;EACA;AACJ;AACA;EACI,SAASgB,uBAAuBA,CAAChB,CAAC,EAAE;IAChC,OAAOJ,YAAY,CAACE,OAAO,CAACkB,uBAAuB,GAC7CpB,YAAY,CAACE,OAAO,CAACkB,uBAAuB,CAAC7B,KAAK,CAACW,OAAO,EAAEE,CAAC,CAAC,GAC9D,KAAK;EACf;EACA;AACJ;AACA;EACI,SAAS2B,eAAeA,CAAC3B,CAAC,EAAE;IACxB,OAAOJ,YAAY,CAACE,OAAO,CAAC6B,eAAe,GACrC/B,YAAY,CAACE,OAAO,CAAC6B,eAAe,CAACxC,KAAK,CAACW,OAAO,EAAEE,CAAC,CAAC,GACtD,KAAK;EACf;EACA;AACJ;AACA;AACA;EACI,SAASwB,sBAAsBA,CAACxB,CAAC,EAAE;IAC/B,OAAOJ,YAAY,CAACE,OAAO,CAAC0B,sBAAsB,GAC5C5B,YAAY,CAACE,OAAO,CAAC0B,sBAAsB,CAACrC,KAAK,CAACW,OAAO,EAAEE,CAAC,CAAC,GAC7D,KAAK;EACf;EACA;AACJ;AACA;AACA;AACA;EACI,SAASI,OAAOA,CAACJ,CAAC,EAAE;IAChB,IAAIJ,YAAY,CAACE,OAAO,CAACM,OAAO,EAAE;MAC9BR,YAAY,CAACE,OAAO,CAACM,OAAO,CAACjB,KAAK,CAACW,OAAO,EAAEE,CAAC,CAAC;IAClD;EACJ;EACA;AACJ;AACA;AACA;EACI,SAASc,gBAAgBA,CAACd,CAAC,EAAE;IACzB,IAAIX,EAAE,GAAGW,CAAC,CAAC4B,OAAO,IAAI5B,CAAC,CAAC4B,OAAO,CAAC,CAAC,CAAC,GAAG5B,CAAC,CAAC4B,OAAO,CAAC,CAAC,CAAC,GAAG5B,CAAC;MAAE6B,KAAK,GAAGxC,EAAE,CAACwC,KAAK;MAAEC,KAAK,GAAGzC,EAAE,CAACyC,KAAK;IACzF,IAAIC,CAAC,GAAG5C,KAAK,CAACW,OAAO;IACrBX,KAAK,CAACW,OAAO,GAAGlC,OAAO,CAAC0B,QAAQ,CAAC,CAAC,CAAC,EAAEvB,YAAY,EAAE;MAAEW,SAAS,EAAEqD,CAAC,CAACrD,SAAS,IAAIX,YAAY,CAACW,SAAS;MAAEP,EAAE,EAAE,CAAC0D,KAAK,EAAEC,KAAK,CAAC;MAAEzD,OAAO,EAAE,CAACwD,KAAK,EAAEC,KAAK,CAAC;MAAExD,QAAQ,EAAE,CAACuD,KAAK,EAAEC,KAAK,CAAC;MAAE9D,IAAI,EAAEC,IAAI,CAACC,GAAG;IAAG,CAAC,CAAC;EACrM;EACA;AACJ;AACA;AACA;EACI,SAASqD,eAAeA,CAACvB,CAAC,EAAE;IACxB,IAAIX,EAAE,GAAGW,CAAC,CAAC4B,OAAO,IAAI5B,CAAC,CAAC4B,OAAO,CAAC,CAAC,CAAC,GAAG5B,CAAC,CAAC4B,OAAO,CAAC,CAAC,CAAC,GAAG5B,CAAC;MAAE6B,KAAK,GAAGxC,EAAE,CAACwC,KAAK;MAAEC,KAAK,GAAGzC,EAAE,CAACyC,KAAK;IACzF,IAAIC,CAAC,GAAG5C,KAAK,CAACW,OAAO;IACrB,IAAI9B,IAAI,GAAGC,IAAI,CAACC,GAAG,EAAE;IACrB,IAAI8D,MAAM,GAAGH,KAAK,GAAGE,CAAC,CAAC5D,EAAE,CAAC,CAAC,CAAC;IAC5B,IAAI8D,MAAM,GAAGH,KAAK,GAAGC,CAAC,CAAC5D,EAAE,CAAC,CAAC,CAAC;IAC5B,IAAI+D,OAAO,GAAGL,KAAK,GAAGE,CAAC,CAAC1D,OAAO,CAAC,CAAC,CAAC;IAClC,IAAI8D,OAAO,GAAGL,KAAK,GAAGC,CAAC,CAAC1D,OAAO,CAAC,CAAC,CAAC;IAClC,IAAIO,QAAQ,GAAGa,IAAI,CAAC2C,IAAI,CAACF,OAAO,GAAGA,OAAO,GAAGC,OAAO,GAAGA,OAAO,CAAC;IAC/D,IAAIE,GAAG,GAAG5C,IAAI,CAAC2C,IAAI,CAACJ,MAAM,GAAGA,MAAM,GAAGC,MAAM,GAAGA,MAAM,CAAC;IACtD,IAAIK,MAAM,GAAG,CAAC,IAAID,GAAG,IAAI,CAAC,CAAC;IAC3B,IAAI1D,QAAQ,GAAG0D,GAAG,IAAIrE,IAAI,GAAG+D,CAAC,CAAC/D,IAAI,CAAC;IACpC,IAAIQ,gBAAgB,GAAGuD,CAAC,CAACvD,gBAAgB,CAAC,CAAC,CAAC,KAAK,CAAC,IAAIuD,CAAC,CAACvD,gBAAgB,CAAC,CAAC,CAAC,KAAK,CAAC,GAC3EuD,CAAC,CAACvD,gBAAgB,GAClB,CAAC0D,OAAO,GAAGI,MAAM,EAAEH,OAAO,GAAGG,MAAM,CAAC;IAC1CnD,KAAK,CAACW,OAAO,GAAGlC,OAAO,CAAC0B,QAAQ,CAAC,CAAC,CAAC,EAAEH,KAAK,CAACW,OAAO,EAAE;MAAE9B,IAAI,EAAEA,IAAI;MAAEG,EAAE,EAAE,CAAC0D,KAAK,EAAEC,KAAK,CAAC;MAAEtD,gBAAgB,EAAEA,gBAAgB;MAAEJ,KAAK,EAAE,CAAC8D,OAAO,EAAEC,OAAO,CAAC;MAAE1D,KAAK,EAAE,CACpJsD,CAAC,CAACrD,SAAS,CAAC,CAAC,CAAC,GAAGmD,KAAK,GAAGE,CAAC,CAAC1D,OAAO,CAAC,CAAC,CAAC,EACrC0D,CAAC,CAACrD,SAAS,CAAC,CAAC,CAAC,GAAGoD,KAAK,GAAGC,CAAC,CAAC1D,OAAO,CAAC,CAAC,CAAC,CACxC;MAAEM,QAAQ,EAAEX,IAAI,GAAG+D,CAAC,CAAC/D,IAAI,KAAK,CAAC,GAAG+D,CAAC,CAACpD,QAAQ,GAAGA,QAAQ;MAAEC,QAAQ,EAAEA,QAAQ;MAAEL,SAAS,EAAE,CAACyD,MAAM,GAAGM,MAAM,EAAEL,MAAM,GAAGK,MAAM,CAAC;MAAEhE,QAAQ,EAAEyD,CAAC,CAAC5D;IAAG,CAAC,CAAC;EACtJ;EACA;AACJ;AACA;AACA;EACI,SAASuD,MAAMA,CAAC1B,CAAC,EAAE;IACf,IAAIL,OAAO,CAACG,OAAO,IAAIF,YAAY,CAACE,OAAO,CAAC4B,MAAM,EAAE;MAChD9B,YAAY,CAACE,OAAO,CAAC4B,MAAM,CAACvC,KAAK,CAACW,OAAO,EAAEE,CAAC,CAAC;IACjD;EACJ;EACA;AACJ;AACA;AACA;AACA;EACI,SAASqB,SAASA,CAACrB,CAAC,EAAE;IAClB,IAAI+B,CAAC,GAAG5C,KAAK,CAACW,OAAO;IACrBX,KAAK,CAACW,OAAO,GAAGlC,OAAO,CAAC0B,QAAQ,CAAC,CAAC,CAAC,EAAEH,KAAK,CAACW,OAAO,EAAE;MAAEpB,SAAS,EAAEqD,CAAC,CAACtD;IAAM,CAAC,CAAC;IAC3E,IAAImB,YAAY,CAACE,OAAO,CAACuB,SAAS,EAAE;MAChCzB,YAAY,CAACE,OAAO,CAACuB,SAAS,CAAClC,KAAK,CAACW,OAAO,EAAEE,CAAC,CAAC;IACpD;IACAjB,YAAY,GAAG,IAAI;EACvB;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,SAASkB,oBAAoBA,CAACD,CAAC,EAAE;IAC7B,OAAOJ,YAAY,CAACE,OAAO,CAACG,oBAAoB,GAC1CL,YAAY,CAACE,OAAO,CAACG,oBAAoB,CAACd,KAAK,CAACW,OAAO,EAAEE,CAAC,CAAC,GAC3D,IAAI;EACd;EACA;AACJ;AACA;EACI,SAASE,WAAWA,CAACF,CAAC,EAAE;IACpB,IAAI+B,CAAC,GAAG5C,KAAK,CAACW,OAAO;IACrBX,KAAK,CAACW,OAAO,GAAGlC,OAAO,CAAC0B,QAAQ,CAAC,CAAC,CAAC,EAAEH,KAAK,CAACW,OAAO,EAAE;MAAEpB,SAAS,EAAEqD,CAAC,CAACtD;IAAM,CAAC,CAAC;IAC3E,IAAImB,YAAY,CAACE,OAAO,CAACI,WAAW,EAAE;MAClCN,YAAY,CAACE,OAAO,CAACI,WAAW,CAACf,KAAK,CAACW,OAAO,EAAEE,CAAC,CAAC;IACtD;EACJ;EACA;AACJ;AACA;AACA;EACI,SAASQ,eAAeA,CAACR,CAAC,EAAE;IACxB,IAAIlC,cAAc,EAAE,EAAE;MAClB2D,UAAU,CAACzB,CAAC,CAAC;IACjB;EACJ;EACA,SAASS,sBAAsBA,CAACT,CAAC,EAAE;IAC/B,IAAIlC,cAAc,EAAE,EAAE;MAClBwD,iBAAiB,CAACtB,CAAC,CAAC;IACxB;EACJ;EACA,SAASU,cAAcA,CAACV,CAAC,EAAE;IACvB,IAAIlC,cAAc,EAAE,EAAE;MAClBsD,SAAS,CAACpB,CAAC,CAAC;IAChB;EACJ;EACAnC,KAAK,CAACgC,SAAS,CAAC,YAAY;IAAE,OAAOc,uBAAuB;EAAE,CAAC,EAAE,EAAE,CAAC;EACpE;AACJ;AACA;EACI,SAAS4B,yBAAyBA,CAAA,EAAG;IACjC,IAAIxD,YAAY,EAAE;MACdA,YAAY,CAACmB,WAAW,EAAE;MAC1BnB,YAAY,GAAG,IAAI;IACvB;EACJ;EACA;AACJ;AACA;AACA;EACI,SAASyD,mBAAmBA,CAAA,EAAG;IAC3B,OAAOzD,YAAY;EACvB;EACA;AACJ;AACA;EACI,IAAI0D,WAAW,GAAG;IACdC,YAAY,EAAEzB,WAAW;IACzB0B,UAAU,EAAEvB,SAAS;IACrBwB,WAAW,EAAEnB,UAAU;IACvBoB,mBAAmB,EAAEhC,kBAAkB;IACvCiC,kBAAkB,EAAExB;EACxB,CAAC;EACD,IAAIyB,WAAW,GAAGjE,WAAW,GACvB;IACEkE,WAAW,EAAE,SAAAA,CAAUhD,CAAC,EAAE;MACtB,IAAIlC,cAAc,EAAE,EAAE;QAClBmD,WAAW,CAACjB,CAAC,CAAC;MAClB;IACJ,CAAC;IACDiD,kBAAkB,EAAE,SAAAA,CAAUjD,CAAC,EAAE;MAC7B,IAAIlC,cAAc,EAAE,EAAE;QAClB+C,kBAAkB,CAACb,CAAC,CAAC;MACzB;IACJ;EACJ,CAAC,GACC,CAAC,CAAC;EACR,OAAO;IACHkD,IAAI,EAAEtF,OAAO,CAAC0B,QAAQ,CAAC,CAAC,CAAC,EAAEmD,WAAW,EAAEM,WAAW,CAAC;IACpDR,yBAAyB,EAAEA,yBAAyB;IACpDC,mBAAmB,EAAEA;EACzB,CAAC;AACL"},"metadata":{},"sourceType":"module","externalDependencies":[]}