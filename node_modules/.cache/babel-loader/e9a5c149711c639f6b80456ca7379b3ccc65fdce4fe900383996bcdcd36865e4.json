{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport * as React from \"react\";\nimport { getPositionForIndex, getIndexFromCoordinates } from \"./helpers\";\nvar noop = function () {\n  throw new Error(\"Make sure that you have wrapped your drop zones with GridContext\");\n};\nexport var GridContext = React.createContext({\n  register: noop,\n  remove: noop,\n  getActiveDropId: noop,\n  startTraverse: noop,\n  measureAll: noop,\n  traverse: null,\n  endTraverse: noop,\n  onChange: noop\n});\nexport function GridContextProvider(_a) {\n  var children = _a.children,\n    onChange = _a.onChange;\n  var _b = tslib_1.__read(React.useState(null), 2),\n    traverse = _b[0],\n    setTraverse = _b[1];\n  var dropRefs = React.useRef(new Map());\n  /**\n   * Register a drop zone with relevant information\n   * @param id\n   * @param options\n   */\n  function register(id, options) {\n    dropRefs.current.set(id, options);\n  }\n  /**\n   * Remove a drop zone (typically on unmount)\n   * @param id\n   */\n  function remove(id) {\n    dropRefs.current.delete(id);\n  }\n  /**\n   * Determine the fixed position (pageX) of an item\n   * @param sourceId\n   * @param rx relative x\n   * @param ry relative y\n   */\n  function getFixedPosition(sourceId, rx, ry) {\n    var item = dropRefs.current.get(sourceId);\n    // When items are removed from the DOM, the left and top values could be undefined.\n    if (!item) {\n      return {\n        x: rx,\n        y: ry\n      };\n    }\n    var left = item.left,\n      top = item.top;\n    return {\n      x: left + rx,\n      y: top + ry\n    };\n  }\n  /**\n   * Get a relative position for a target dropzone given\n   * a fixed position\n   * @param targetId\n   * @param fx fixed x\n   * @param fy fixed y\n   */\n  function getRelativePosition(targetId, fx, fy) {\n    var _a = dropRefs.current.get(targetId),\n      left = _a.left,\n      top = _a.top;\n    return {\n      x: fx - left,\n      y: fy - top\n    };\n  }\n  /**\n   * Determine the difference in coordinates between\n   * two dropzones\n   * @param sourceId\n   * @param targetId\n   */\n  function diffDropzones(sourceId, targetId) {\n    var sBounds = dropRefs.current.get(sourceId);\n    var tBounds = dropRefs.current.get(targetId);\n    return {\n      x: tBounds.left - sBounds.left,\n      y: tBounds.top - sBounds.top\n    };\n  }\n  /**\n   * Determine which dropzone we are actively dragging over\n   * @param sourceId\n   * @param x\n   * @param y\n   */\n  function getActiveDropId(sourceId, x, y) {\n    var e_1, _a;\n    var _b = getFixedPosition(sourceId, x, y),\n      fx = _b.x,\n      fy = _b.y;\n    try {\n      // probably faster just using an array for dropRefs\n      for (var _c = tslib_1.__values(dropRefs.current.entries()), _d = _c.next(); !_d.done; _d = _c.next()) {\n        var _e = tslib_1.__read(_d.value, 2),\n          key = _e[0],\n          bounds = _e[1];\n        if (!bounds.disableDrop && fx > bounds.left && fx < bounds.right && fy > bounds.top && fy < bounds.bottom) {\n          return key;\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n    return null;\n  }\n  /**\n   * Trigger a traversal (when one item is being dropped\n   * on a different dropzone)\n   * @param sourceId\n   * @param targetId\n   * @param x\n   * @param y\n   * @param sourceIndex\n   */\n  function startTraverse(sourceId, targetId, x, y, sourceIndex) {\n    var _a = getFixedPosition(sourceId, x, y),\n      fx = _a.x,\n      fy = _a.y;\n    var _b = getRelativePosition(targetId, fx, fy),\n      rx = _b.x,\n      ry = _b.y;\n    var _c = dropRefs.current.get(targetId),\n      targetGrid = _c.grid,\n      count = _c.count;\n    var targetIndex = getIndexFromCoordinates(rx + targetGrid.columnWidth / 2, ry + targetGrid.rowHeight / 2, targetGrid, count);\n    var _d = tslib_1.__read(getPositionForIndex(targetIndex, targetGrid).xy, 2),\n      px = _d[0],\n      py = _d[1];\n    var _e = diffDropzones(sourceId, targetId),\n      dx = _e.x,\n      dy = _e.y;\n    // only update traverse if targetId or targetIndex have changed\n    if (!traverse || !(traverse && traverse.targetIndex !== targetIndex && traverse.targetId !== targetId)) {\n      setTraverse({\n        rx: px + dx,\n        ry: py + dy,\n        tx: rx,\n        ty: ry,\n        sourceId: sourceId,\n        targetId: targetId,\n        sourceIndex: sourceIndex,\n        targetIndex: targetIndex\n      });\n    }\n  }\n  /**\n   * End any active traversals\n   */\n  function endTraverse() {\n    setTraverse(null);\n  }\n  /**\n   * Perform a change to list item arrays.\n   * If it doesn't include targetId, it's a switch\n   * of order within the one array itself.\n   */\n  function onSwitch(sourceId, sourceIndex, targetIndex, targetId) {\n    // this is a bit hacky, but seems to work for now. The idea\n    // is that we want our newly mounted traversed grid item\n    // to start its animation from the last target location.\n    // Execute informs our GridDropZone to remove the placeholder\n    // but to pass the initial location to the newly mounted\n    // grid item at the specified index.\n    // The problem here is that it's async, so potentially something\n    // could mount in its place in between setTraversal and onChange\n    // executing. Or maybe onChange won't do anything, in which case\n    // our state is kinda messed up.\n    // So it's sorta a controlled component, but not really, because\n    // if you don't do what we suggest, then it gets messed up.\n    // One solution is to bring the state in-component and force\n    // the state to be updated by us, since it's basically required\n    // anyway.\n    // We could possibly also use a unique identifier for the grid (besides\n    // the index). This could still result in weirdness, but would\n    // be more unlikely.\n    // Ultimately it's kinda messed because we are trying to do something\n    // imperative in a declarative interface.\n    setTraverse(tslib_1.__assign({}, traverse, {\n      execute: true\n    }));\n    onChange(sourceId, sourceIndex, targetIndex, targetId);\n  }\n  function measureAll() {\n    dropRefs.current.forEach(function (ref) {\n      ref.remeasure();\n    });\n  }\n  return React.createElement(GridContext.Provider, {\n    value: {\n      register: register,\n      remove: remove,\n      getActiveDropId: getActiveDropId,\n      startTraverse: startTraverse,\n      traverse: traverse,\n      measureAll: measureAll,\n      endTraverse: endTraverse,\n      onChange: onSwitch\n    }\n  }, children);\n}","map":{"version":3,"names":["tslib_1","React","getPositionForIndex","getIndexFromCoordinates","noop","Error","GridContext","createContext","register","remove","getActiveDropId","startTraverse","measureAll","traverse","endTraverse","onChange","GridContextProvider","_a","children","_b","__read","useState","setTraverse","dropRefs","useRef","Map","id","options","current","set","delete","getFixedPosition","sourceId","rx","ry","item","get","x","y","left","top","getRelativePosition","targetId","fx","fy","diffDropzones","sBounds","tBounds","e_1","_c","__values","entries","_d","next","done","_e","value","key","bounds","disableDrop","right","bottom","e_1_1","error","return","call","sourceIndex","targetGrid","grid","count","targetIndex","columnWidth","rowHeight","xy","px","py","dx","dy","tx","ty","onSwitch","__assign","execute","forEach","ref","remeasure","createElement","Provider"],"sources":["C:/Users/LearnForce/Desktop/Task/puzzle-app/node_modules/react-grid-dnd/esm/GridContext.js"],"sourcesContent":["import * as tslib_1 from \"tslib\";\nimport * as React from \"react\";\nimport { getPositionForIndex, getIndexFromCoordinates } from \"./helpers\";\nvar noop = function () {\n    throw new Error(\"Make sure that you have wrapped your drop zones with GridContext\");\n};\nexport var GridContext = React.createContext({\n    register: noop,\n    remove: noop,\n    getActiveDropId: noop,\n    startTraverse: noop,\n    measureAll: noop,\n    traverse: null,\n    endTraverse: noop,\n    onChange: noop\n});\nexport function GridContextProvider(_a) {\n    var children = _a.children, onChange = _a.onChange;\n    var _b = tslib_1.__read(React.useState(null), 2), traverse = _b[0], setTraverse = _b[1];\n    var dropRefs = React.useRef(new Map());\n    /**\n     * Register a drop zone with relevant information\n     * @param id\n     * @param options\n     */\n    function register(id, options) {\n        dropRefs.current.set(id, options);\n    }\n    /**\n     * Remove a drop zone (typically on unmount)\n     * @param id\n     */\n    function remove(id) {\n        dropRefs.current.delete(id);\n    }\n    /**\n     * Determine the fixed position (pageX) of an item\n     * @param sourceId\n     * @param rx relative x\n     * @param ry relative y\n     */\n    function getFixedPosition(sourceId, rx, ry) {\n        var item = dropRefs.current.get(sourceId);\n        // When items are removed from the DOM, the left and top values could be undefined.\n        if (!item) {\n            return {\n                x: rx,\n                y: ry\n            };\n        }\n        var left = item.left, top = item.top;\n        return {\n            x: left + rx,\n            y: top + ry\n        };\n    }\n    /**\n     * Get a relative position for a target dropzone given\n     * a fixed position\n     * @param targetId\n     * @param fx fixed x\n     * @param fy fixed y\n     */\n    function getRelativePosition(targetId, fx, fy) {\n        var _a = dropRefs.current.get(targetId), left = _a.left, top = _a.top;\n        return {\n            x: fx - left,\n            y: fy - top\n        };\n    }\n    /**\n     * Determine the difference in coordinates between\n     * two dropzones\n     * @param sourceId\n     * @param targetId\n     */\n    function diffDropzones(sourceId, targetId) {\n        var sBounds = dropRefs.current.get(sourceId);\n        var tBounds = dropRefs.current.get(targetId);\n        return {\n            x: tBounds.left - sBounds.left,\n            y: tBounds.top - sBounds.top\n        };\n    }\n    /**\n     * Determine which dropzone we are actively dragging over\n     * @param sourceId\n     * @param x\n     * @param y\n     */\n    function getActiveDropId(sourceId, x, y) {\n        var e_1, _a;\n        var _b = getFixedPosition(sourceId, x, y), fx = _b.x, fy = _b.y;\n        try {\n            // probably faster just using an array for dropRefs\n            for (var _c = tslib_1.__values(dropRefs.current.entries()), _d = _c.next(); !_d.done; _d = _c.next()) {\n                var _e = tslib_1.__read(_d.value, 2), key = _e[0], bounds = _e[1];\n                if (!bounds.disableDrop &&\n                    fx > bounds.left &&\n                    fx < bounds.right &&\n                    fy > bounds.top &&\n                    fy < bounds.bottom) {\n                    return key;\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        return null;\n    }\n    /**\n     * Trigger a traversal (when one item is being dropped\n     * on a different dropzone)\n     * @param sourceId\n     * @param targetId\n     * @param x\n     * @param y\n     * @param sourceIndex\n     */\n    function startTraverse(sourceId, targetId, x, y, sourceIndex) {\n        var _a = getFixedPosition(sourceId, x, y), fx = _a.x, fy = _a.y;\n        var _b = getRelativePosition(targetId, fx, fy), rx = _b.x, ry = _b.y;\n        var _c = dropRefs.current.get(targetId), targetGrid = _c.grid, count = _c.count;\n        var targetIndex = getIndexFromCoordinates(rx + targetGrid.columnWidth / 2, ry + targetGrid.rowHeight / 2, targetGrid, count);\n        var _d = tslib_1.__read(getPositionForIndex(targetIndex, targetGrid).xy, 2), px = _d[0], py = _d[1];\n        var _e = diffDropzones(sourceId, targetId), dx = _e.x, dy = _e.y;\n        // only update traverse if targetId or targetIndex have changed\n        if (!traverse ||\n            !(traverse &&\n                traverse.targetIndex !== targetIndex &&\n                traverse.targetId !== targetId)) {\n            setTraverse({\n                rx: px + dx,\n                ry: py + dy,\n                tx: rx,\n                ty: ry,\n                sourceId: sourceId,\n                targetId: targetId,\n                sourceIndex: sourceIndex,\n                targetIndex: targetIndex\n            });\n        }\n    }\n    /**\n     * End any active traversals\n     */\n    function endTraverse() {\n        setTraverse(null);\n    }\n    /**\n     * Perform a change to list item arrays.\n     * If it doesn't include targetId, it's a switch\n     * of order within the one array itself.\n     */\n    function onSwitch(sourceId, sourceIndex, targetIndex, targetId) {\n        // this is a bit hacky, but seems to work for now. The idea\n        // is that we want our newly mounted traversed grid item\n        // to start its animation from the last target location.\n        // Execute informs our GridDropZone to remove the placeholder\n        // but to pass the initial location to the newly mounted\n        // grid item at the specified index.\n        // The problem here is that it's async, so potentially something\n        // could mount in its place in between setTraversal and onChange\n        // executing. Or maybe onChange won't do anything, in which case\n        // our state is kinda messed up.\n        // So it's sorta a controlled component, but not really, because\n        // if you don't do what we suggest, then it gets messed up.\n        // One solution is to bring the state in-component and force\n        // the state to be updated by us, since it's basically required\n        // anyway.\n        // We could possibly also use a unique identifier for the grid (besides\n        // the index). This could still result in weirdness, but would\n        // be more unlikely.\n        // Ultimately it's kinda messed because we are trying to do something\n        // imperative in a declarative interface.\n        setTraverse(tslib_1.__assign({}, traverse, { execute: true }));\n        onChange(sourceId, sourceIndex, targetIndex, targetId);\n    }\n    function measureAll() {\n        dropRefs.current.forEach(function (ref) {\n            ref.remeasure();\n        });\n    }\n    return (React.createElement(GridContext.Provider, { value: {\n            register: register,\n            remove: remove,\n            getActiveDropId: getActiveDropId,\n            startTraverse: startTraverse,\n            traverse: traverse,\n            measureAll: measureAll,\n            endTraverse: endTraverse,\n            onChange: onSwitch\n        } }, children));\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}