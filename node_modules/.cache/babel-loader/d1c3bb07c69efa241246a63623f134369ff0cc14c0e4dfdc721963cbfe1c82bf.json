{"ast":null,"code":"import * as tslib_1 from \"tslib\";\n/**\n * Get the active drag position given its initial\n * coordinates and grid meta\n * @param index\n * @param grid\n * @param dx\n * @param dy\n */\nexport function getDragPosition(index, grid, dx, dy, center) {\n  var _a = tslib_1.__read(getPositionForIndex(index, grid).xy, 2),\n    left = _a[0],\n    top = _a[1];\n  return {\n    xy: [left + dx + (center ? grid.columnWidth / 2 : 0), top + dy + (center ? grid.rowHeight / 2 : 0)]\n  };\n}\n/**\n * Get the relative top, left position for a particular\n * index in a grid\n * @param i\n * @param grid\n * @param traverseIndex (destination for traverse)\n */\nexport function getPositionForIndex(i, _a, traverseIndex) {\n  var boxesPerRow = _a.boxesPerRow,\n    rowHeight = _a.rowHeight,\n    columnWidth = _a.columnWidth;\n  var index = typeof traverseIndex == \"number\" ? i >= traverseIndex ? i + 1 : i : i;\n  var x = index % boxesPerRow * columnWidth;\n  var y = Math.floor(index / boxesPerRow) * rowHeight;\n  return {\n    xy: [x, y]\n  };\n}\n/**\n * Given relative coordinates, determine which index\n * we are currently in\n * @param x\n * @param y\n * @param param2\n */\nexport function getIndexFromCoordinates(x, y, _a, count) {\n  var rowHeight = _a.rowHeight,\n    boxesPerRow = _a.boxesPerRow,\n    columnWidth = _a.columnWidth;\n  var index = Math.floor(y / rowHeight) * boxesPerRow + Math.floor(x / columnWidth);\n  return index >= count ? count : index;\n}\n/**\n * Get the target index during a drag\n * @param startIndex\n * @param grid\n * @param count\n * @param dx\n * @param dy\n */\nexport function getTargetIndex(startIndex, grid, count, dx, dy) {\n  var _a = tslib_1.__read(getDragPosition(startIndex, grid, dx, dy, true).xy, 2),\n    cx = _a[0],\n    cy = _a[1];\n  return getIndexFromCoordinates(cx, cy, grid, count);\n}","map":{"version":3,"names":["tslib_1","getDragPosition","index","grid","dx","dy","center","_a","__read","getPositionForIndex","xy","left","top","columnWidth","rowHeight","i","traverseIndex","boxesPerRow","x","y","Math","floor","getIndexFromCoordinates","count","getTargetIndex","startIndex","cx","cy"],"sources":["C:/Users/LearnForce/Desktop/Task/puzzle-app/node_modules/react-grid-dnd/esm/helpers.js"],"sourcesContent":["import * as tslib_1 from \"tslib\";\n/**\n * Get the active drag position given its initial\n * coordinates and grid meta\n * @param index\n * @param grid\n * @param dx\n * @param dy\n */\nexport function getDragPosition(index, grid, dx, dy, center) {\n    var _a = tslib_1.__read(getPositionForIndex(index, grid).xy, 2), left = _a[0], top = _a[1];\n    return {\n        xy: [\n            left + dx + (center ? grid.columnWidth / 2 : 0),\n            top + dy + (center ? grid.rowHeight / 2 : 0)\n        ]\n    };\n}\n/**\n * Get the relative top, left position for a particular\n * index in a grid\n * @param i\n * @param grid\n * @param traverseIndex (destination for traverse)\n */\nexport function getPositionForIndex(i, _a, traverseIndex) {\n    var boxesPerRow = _a.boxesPerRow, rowHeight = _a.rowHeight, columnWidth = _a.columnWidth;\n    var index = typeof traverseIndex == \"number\" ? (i >= traverseIndex ? i + 1 : i) : i;\n    var x = (index % boxesPerRow) * columnWidth;\n    var y = Math.floor(index / boxesPerRow) * rowHeight;\n    return {\n        xy: [x, y]\n    };\n}\n/**\n * Given relative coordinates, determine which index\n * we are currently in\n * @param x\n * @param y\n * @param param2\n */\nexport function getIndexFromCoordinates(x, y, _a, count) {\n    var rowHeight = _a.rowHeight, boxesPerRow = _a.boxesPerRow, columnWidth = _a.columnWidth;\n    var index = Math.floor(y / rowHeight) * boxesPerRow + Math.floor(x / columnWidth);\n    return index >= count ? count : index;\n}\n/**\n * Get the target index during a drag\n * @param startIndex\n * @param grid\n * @param count\n * @param dx\n * @param dy\n */\nexport function getTargetIndex(startIndex, grid, count, dx, dy) {\n    var _a = tslib_1.__read(getDragPosition(startIndex, grid, dx, dy, true).xy, 2), cx = _a[0], cy = _a[1];\n    return getIndexFromCoordinates(cx, cy, grid, count);\n}\n"],"mappings":"AAAA,OAAO,KAAKA,OAAO,MAAM,OAAO;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,eAAeA,CAACC,KAAK,EAAEC,IAAI,EAAEC,EAAE,EAAEC,EAAE,EAAEC,MAAM,EAAE;EACzD,IAAIC,EAAE,GAAGP,OAAO,CAACQ,MAAM,CAACC,mBAAmB,CAACP,KAAK,EAAEC,IAAI,CAAC,CAACO,EAAE,EAAE,CAAC,CAAC;IAAEC,IAAI,GAAGJ,EAAE,CAAC,CAAC,CAAC;IAAEK,GAAG,GAAGL,EAAE,CAAC,CAAC,CAAC;EAC1F,OAAO;IACHG,EAAE,EAAE,CACAC,IAAI,GAAGP,EAAE,IAAIE,MAAM,GAAGH,IAAI,CAACU,WAAW,GAAG,CAAC,GAAG,CAAC,CAAC,EAC/CD,GAAG,GAAGP,EAAE,IAAIC,MAAM,GAAGH,IAAI,CAACW,SAAS,GAAG,CAAC,GAAG,CAAC,CAAC;EAEpD,CAAC;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASL,mBAAmBA,CAACM,CAAC,EAAER,EAAE,EAAES,aAAa,EAAE;EACtD,IAAIC,WAAW,GAAGV,EAAE,CAACU,WAAW;IAAEH,SAAS,GAAGP,EAAE,CAACO,SAAS;IAAED,WAAW,GAAGN,EAAE,CAACM,WAAW;EACxF,IAAIX,KAAK,GAAG,OAAOc,aAAa,IAAI,QAAQ,GAAID,CAAC,IAAIC,aAAa,GAAGD,CAAC,GAAG,CAAC,GAAGA,CAAC,GAAIA,CAAC;EACnF,IAAIG,CAAC,GAAIhB,KAAK,GAAGe,WAAW,GAAIJ,WAAW;EAC3C,IAAIM,CAAC,GAAGC,IAAI,CAACC,KAAK,CAACnB,KAAK,GAAGe,WAAW,CAAC,GAAGH,SAAS;EACnD,OAAO;IACHJ,EAAE,EAAE,CAACQ,CAAC,EAAEC,CAAC;EACb,CAAC;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASG,uBAAuBA,CAACJ,CAAC,EAAEC,CAAC,EAAEZ,EAAE,EAAEgB,KAAK,EAAE;EACrD,IAAIT,SAAS,GAAGP,EAAE,CAACO,SAAS;IAAEG,WAAW,GAAGV,EAAE,CAACU,WAAW;IAAEJ,WAAW,GAAGN,EAAE,CAACM,WAAW;EACxF,IAAIX,KAAK,GAAGkB,IAAI,CAACC,KAAK,CAACF,CAAC,GAAGL,SAAS,CAAC,GAAGG,WAAW,GAAGG,IAAI,CAACC,KAAK,CAACH,CAAC,GAAGL,WAAW,CAAC;EACjF,OAAOX,KAAK,IAAIqB,KAAK,GAAGA,KAAK,GAAGrB,KAAK;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASsB,cAAcA,CAACC,UAAU,EAAEtB,IAAI,EAAEoB,KAAK,EAAEnB,EAAE,EAAEC,EAAE,EAAE;EAC5D,IAAIE,EAAE,GAAGP,OAAO,CAACQ,MAAM,CAACP,eAAe,CAACwB,UAAU,EAAEtB,IAAI,EAAEC,EAAE,EAAEC,EAAE,EAAE,IAAI,CAAC,CAACK,EAAE,EAAE,CAAC,CAAC;IAAEgB,EAAE,GAAGnB,EAAE,CAAC,CAAC,CAAC;IAAEoB,EAAE,GAAGpB,EAAE,CAAC,CAAC,CAAC;EACtG,OAAOe,uBAAuB,CAACI,EAAE,EAAEC,EAAE,EAAExB,IAAI,EAAEoB,KAAK,CAAC;AACvD"},"metadata":{},"sourceType":"module","externalDependencies":[]}